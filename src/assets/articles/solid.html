<h2>Co to jest SOLID?</h2>
<p>
  SOLID – mnemonik zaproponowany przez Roberta C. Martina, opisujący pięć podstawowych założeń programowania obiektowego:
</p>
<table>
  <tr>
    <td>S</td>
    <td>
      <strong><a href="article/solid%2Fsingle_responsibility.html">Single responsibility principle (Zasada jednej odpowiedzialności)</a></strong><br>
      Klasa powinna mieć tylko jedną odpowiedzialność (nigdy nie powinien istnieć więcej niż jeden powód do modyfikacji klasy).
    </td>
  </tr>
  <tr>
    <td>O</td>
    <td>
      <strong><a href="article/solid%2Fopen_closed_principle.html">Open/closed principle (Zasada otwarte-zamknięte)</a></strong><br>
      Klasy (encje) powinny być otwarte na rozszerzenia i zamknięte na modyfikacje.
    </td>
  </tr>
  <tr>
    <td>L</td>
    <td>
      <strong><a href="article/solid%2Fliskov_substitution_principle.html">Liskov substitution principle (Zasada podstawienia Liskov)</a></strong><br>
      Funkcje które używają wskaźników lub referencji do klas bazowych, muszą być w stanie używać również obiektów klas dziedziczących po klasach bazowych, bez dokładnej znajomości tych obiektów.
    </td>
  </tr>
  <tr>
    <td>I</td>
    <td>
      <strong><a href="article/solid%2Finterface_segregation_principle.html">Interface segregation principle (Zasada segregacji interfejsów)</a></strong><br>
      Wiele dedykowanych interfejsów jest lepsze niż jeden ogólny.
    </td>
  </tr>
  <tr>
    <td>D</td>
    <td>
      <strong>Dependency inversion principle (Zasada odwrócenia zależności)</strong><br>
      Wysokopoziomowe moduły nie powinny zależeć od modułów niskopoziomowych - zależności między nimi powinny wynikać z abstrakcji.
    </td>
  </tr>
</table>
